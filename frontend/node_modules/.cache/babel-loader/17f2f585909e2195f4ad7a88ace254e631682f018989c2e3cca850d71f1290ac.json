{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useChat.js - Complete File with Dashboard Data Refresh\nimport { useState, useCallback, useRef, useEffect } from 'react';\nconst API_BASE = 'http://localhost:3000';\nexport const useChat = onDataChanged => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [pendingConfirmation, setPendingConfirmation] = useState(null);\n  const [isWaitingForConfirmation, setIsWaitingForConfirmation] = useState(false);\n  const [showHistory, setShowHistory] = useState(false);\n  const [allHistory, setAllHistory] = useState([]);\n  const messagesEndRef = useRef(null);\n\n  // Auto-scroll to bottom when new messages arrive\n  const scrollToBottom = useCallback(() => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: 'smooth'\n    });\n  }, []);\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages, scrollToBottom]);\n\n  // Start with empty chat - no automatic history loading\n  useEffect(() => {\n    console.log('üí¨ Chat initialized - starting fresh');\n    setMessages([]);\n  }, []);\n\n  // Load chat history manually when requested\n  const loadChatHistory = useCallback(async (maxMessages = 20) => {\n    try {\n      console.log('üîÑ Loading chat history on request...');\n      const response = await fetch(`${API_BASE}/api/chat/history`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const history = await response.json();\n      console.log('üìú Chat history loaded:', history.length, 'messages');\n\n      // Transform and limit messages\n      const transformedHistory = Array.isArray(history) ? history.slice(-maxMessages) // Take last N messages\n      .map(msg => ({\n        role: msg.sender === 'user' ? 'user' : 'assistant',\n        content: msg.message || '',\n        timestamp: msg.timestamp,\n        id: msg.id || Date.now() + Math.random(),\n        sender: msg.sender,\n        isHistorical: true // Mark as historical messages\n      })) : [];\n\n      // Replace current messages with historical messages\n      setMessages(transformedHistory);\n      setAllHistory(transformedHistory);\n      setShowHistory(true);\n      console.log('‚úÖ Chat history loaded:', transformedHistory.length, 'messages');\n      return transformedHistory;\n    } catch (error) {\n      console.error('‚ùå Failed to load chat history:', error);\n      return [];\n    }\n  }, []);\n\n  // Clear all messages and start fresh\n  const startFreshChat = useCallback(() => {\n    setMessages([]);\n    setAllHistory([]);\n    setShowHistory(false);\n    setPendingConfirmation(null);\n    setIsWaitingForConfirmation(false);\n    console.log('üÜï Started fresh chat');\n  }, []);\n\n  // Send message to chat API\n  const sendMessage = useCallback(async (messageText, isConfirmation = false) => {\n    if (!messageText.trim() && !isConfirmation) return;\n    console.log('üì§ Sending message:', messageText);\n    const userMessage = {\n      role: 'user',\n      content: messageText,\n      timestamp: new Date().toISOString(),\n      id: Date.now(),\n      sender: 'user'\n    };\n\n    // Add user message to chat immediately\n    if (!isConfirmation) {\n      setMessages(prev => [...prev, userMessage]);\n    }\n    setIsLoading(true);\n    try {\n      const response = await fetch(`${API_BASE}/api/aetheris/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json'\n        },\n        body: JSON.stringify({\n          message: messageText,\n          userId: 'tristen',\n          companyId: 'Markham Investigation & Protection'\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Check if response is HTML instead of JSON\n      const contentType = response.headers.get('content-type');\n      if (!contentType || !contentType.includes('application/json')) {\n        const responseText = await response.text();\n        if (responseText.startsWith('<!DOCTYPE') || responseText.startsWith('<html')) {\n          throw new Error('Received HTML instead of JSON - API endpoint issue');\n        }\n        throw new Error(`Expected JSON, got ${contentType}`);\n      }\n      const result = await response.json();\n      console.log('üî• Chat response:', result);\n\n      // NEW: Check for data changes and trigger dashboard refresh\n      if (result.dataChanges && result.dataChanges.length > 0) {\n        console.log('üìä Data changes detected:', result.dataChanges);\n\n        // Notify dashboard to refresh with a small delay to ensure backend save is complete\n        if (onDataChanged) {\n          setTimeout(() => {\n            console.log('üîÑ Triggering dashboard refresh...');\n            onDataChanged();\n          }, 100);\n        }\n      }\n\n      // Handle confirmation requests\n      if (result.requiresConfirmation) {\n        setPendingConfirmation(result.confirmationData);\n        setIsWaitingForConfirmation(true);\n        const confirmationMessage = {\n          role: 'assistant',\n          content: result.response || result.message,\n          timestamp: new Date().toISOString(),\n          id: Date.now() + 1,\n          requiresConfirmation: true,\n          sender: 'aetheris'\n        };\n        setMessages(prev => [...prev, confirmationMessage]);\n      } else {\n        // Regular response - handle both response and message fields\n        const responseText = result.response || result.message || 'No response received';\n        const assistantMessage = {\n          role: 'assistant',\n          content: responseText,\n          timestamp: result.timestamp || new Date().toISOString(),\n          id: Date.now() + 1,\n          sender: 'aetheris',\n          coresUsed: result.coresUsed || [],\n          newModule: result.newModule || null,\n          dataChanges: result.dataChanges || [] // Include data changes info for debugging\n        };\n        setMessages(prev => [...prev, assistantMessage]);\n\n        // Clear any pending confirmations\n        setPendingConfirmation(null);\n        setIsWaitingForConfirmation(false);\n      }\n      return result;\n    } catch (error) {\n      console.error('‚ùå Chat error:', error);\n      const errorMessage = {\n        role: 'assistant',\n        content: `Sorry, I encountered an error: ${error.message}. Please check that your backend server is running on port 3000.`,\n        timestamp: new Date().toISOString(),\n        id: Date.now() + 1,\n        error: true,\n        sender: 'aetheris'\n      };\n      setMessages(prev => [...prev, errorMessage]);\n      return {\n        error: error.message\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [onDataChanged]); // Add onDataChanged to dependencies\n\n  // Handle confirmation responses\n  const handleConfirmation = useCallback(async confirmed => {\n    if (!pendingConfirmation) return;\n    const confirmationText = confirmed ? 'yes' : 'no';\n\n    // Add user's confirmation to chat\n    const confirmationMessage = {\n      role: 'user',\n      content: `Confirmation: ${confirmationText}`,\n      timestamp: new Date().toISOString(),\n      id: Date.now(),\n      isConfirmation: true,\n      sender: 'user'\n    };\n    setMessages(prev => [...prev, confirmationMessage]);\n\n    // Send confirmation to backend\n    const result = await sendMessage(confirmationText, true);\n\n    // Clear confirmation state\n    setPendingConfirmation(null);\n    setIsWaitingForConfirmation(false);\n    return result;\n  }, [pendingConfirmation, sendMessage]);\n\n  // Cancel pending confirmation\n  const cancelConfirmation = useCallback(() => {\n    setPendingConfirmation(null);\n    setIsWaitingForConfirmation(false);\n    const cancelMessage = {\n      role: 'assistant',\n      content: 'Action cancelled.',\n      timestamp: new Date().toISOString(),\n      id: Date.now(),\n      sender: 'aetheris'\n    };\n    setMessages(prev => [...prev, cancelMessage]);\n  }, []);\n\n  // Retry last message\n  const retryLastMessage = useCallback(() => {\n    const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'user');\n    if (lastUserMessage) {\n      console.log('üîÑ Retrying last message:', lastUserMessage.content);\n      return sendMessage(lastUserMessage.content);\n    }\n  }, [messages, sendMessage]);\n\n  // Test connection\n  const testConnection = useCallback(async () => {\n    try {\n      const response = await fetch(`${API_BASE}/api/health`);\n      if (response.ok) {\n        const data = await response.json();\n        console.log('‚úÖ Backend connection test successful:', data);\n        return {\n          success: true,\n          data\n        };\n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      console.error('‚ùå Backend connection test failed:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }, []);\n  return {\n    messages,\n    isLoading,\n    pendingConfirmation,\n    isWaitingForConfirmation,\n    messagesEndRef,\n    showHistory,\n    allHistory,\n    sendMessage,\n    handleConfirmation,\n    cancelConfirmation,\n    loadChatHistory,\n    startFreshChat,\n    retryLastMessage,\n    testConnection,\n    clearChat: startFreshChat // Alias for backward compatibility\n  };\n};\n_s(useChat, \"Pz+F0vTn9e2xol/SwpySwaSks4U=\");","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","API_BASE","useChat","onDataChanged","_s","messages","setMessages","isLoading","setIsLoading","pendingConfirmation","setPendingConfirmation","isWaitingForConfirmation","setIsWaitingForConfirmation","showHistory","setShowHistory","allHistory","setAllHistory","messagesEndRef","scrollToBottom","_messagesEndRef$curre","current","scrollIntoView","behavior","console","log","loadChatHistory","maxMessages","response","fetch","method","headers","ok","Error","status","statusText","history","json","length","transformedHistory","Array","isArray","slice","map","msg","role","sender","content","message","timestamp","id","Date","now","Math","random","isHistorical","error","startFreshChat","sendMessage","messageText","isConfirmation","trim","userMessage","toISOString","prev","body","JSON","stringify","userId","companyId","contentType","get","includes","responseText","text","startsWith","result","dataChanges","setTimeout","requiresConfirmation","confirmationData","confirmationMessage","assistantMessage","coresUsed","newModule","errorMessage","handleConfirmation","confirmed","confirmationText","cancelConfirmation","cancelMessage","retryLastMessage","lastUserMessage","reverse","find","testConnection","data","success","clearChat"],"sources":["C:/Users/onetr/OneDrive/Desktop/universal-business-platform/universal-business-platform/frontend/src/hooks/useChat.js"],"sourcesContent":["// src/hooks/useChat.js - Complete File with Dashboard Data Refresh\r\nimport { useState, useCallback, useRef, useEffect } from 'react';\r\n\r\nconst API_BASE = 'http://localhost:3000';\r\n\r\nexport const useChat = (onDataChanged) => {\r\n  const [messages, setMessages] = useState([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [pendingConfirmation, setPendingConfirmation] = useState(null);\r\n  const [isWaitingForConfirmation, setIsWaitingForConfirmation] = useState(false);\r\n  const [showHistory, setShowHistory] = useState(false);\r\n  const [allHistory, setAllHistory] = useState([]);\r\n  const messagesEndRef = useRef(null);\r\n\r\n  // Auto-scroll to bottom when new messages arrive\r\n  const scrollToBottom = useCallback(() => {\r\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    scrollToBottom();\r\n  }, [messages, scrollToBottom]);\r\n\r\n  // Start with empty chat - no automatic history loading\r\n  useEffect(() => {\r\n    console.log('üí¨ Chat initialized - starting fresh');\r\n    setMessages([]);\r\n  }, []);\r\n\r\n  // Load chat history manually when requested\r\n  const loadChatHistory = useCallback(async (maxMessages = 20) => {\r\n    try {\r\n      console.log('üîÑ Loading chat history on request...');\r\n      const response = await fetch(`${API_BASE}/api/chat/history`, {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json'\r\n        }\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n      }\r\n      \r\n      const history = await response.json();\r\n      console.log('üìú Chat history loaded:', history.length, 'messages');\r\n      \r\n      // Transform and limit messages\r\n      const transformedHistory = Array.isArray(history) ? history\r\n        .slice(-maxMessages) // Take last N messages\r\n        .map(msg => ({\r\n          role: msg.sender === 'user' ? 'user' : 'assistant',\r\n          content: msg.message || '',\r\n          timestamp: msg.timestamp,\r\n          id: msg.id || Date.now() + Math.random(),\r\n          sender: msg.sender,\r\n          isHistorical: true // Mark as historical messages\r\n        })) : [];\r\n      \r\n      // Replace current messages with historical messages\r\n      setMessages(transformedHistory);\r\n      setAllHistory(transformedHistory);\r\n      setShowHistory(true);\r\n      \r\n      console.log('‚úÖ Chat history loaded:', transformedHistory.length, 'messages');\r\n      return transformedHistory;\r\n    } catch (error) {\r\n      console.error('‚ùå Failed to load chat history:', error);\r\n      return [];\r\n    }\r\n  }, []);\r\n\r\n  // Clear all messages and start fresh\r\n  const startFreshChat = useCallback(() => {\r\n    setMessages([]);\r\n    setAllHistory([]);\r\n    setShowHistory(false);\r\n    setPendingConfirmation(null);\r\n    setIsWaitingForConfirmation(false);\r\n    console.log('üÜï Started fresh chat');\r\n  }, []);\r\n\r\n  // Send message to chat API\r\n  const sendMessage = useCallback(async (messageText, isConfirmation = false) => {\r\n    if (!messageText.trim() && !isConfirmation) return;\r\n\r\n    console.log('üì§ Sending message:', messageText);\r\n\r\n    const userMessage = {\r\n      role: 'user',\r\n      content: messageText,\r\n      timestamp: new Date().toISOString(),\r\n      id: Date.now(),\r\n      sender: 'user'\r\n    };\r\n\r\n    // Add user message to chat immediately\r\n    if (!isConfirmation) {\r\n      setMessages(prev => [...prev, userMessage]);\r\n    }\r\n\r\n    setIsLoading(true);\r\n\r\n    try {\r\n      const response = await fetch(`${API_BASE}/api/aetheris/chat`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n          message: messageText,\r\n          userId: 'tristen',\r\n          companyId: 'Markham Investigation & Protection'\r\n        })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n      }\r\n\r\n      // Check if response is HTML instead of JSON\r\n      const contentType = response.headers.get('content-type');\r\n      if (!contentType || !contentType.includes('application/json')) {\r\n        const responseText = await response.text();\r\n        if (responseText.startsWith('<!DOCTYPE') || responseText.startsWith('<html')) {\r\n          throw new Error('Received HTML instead of JSON - API endpoint issue');\r\n        }\r\n        throw new Error(`Expected JSON, got ${contentType}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n      console.log('üî• Chat response:', result);\r\n      \r\n      // NEW: Check for data changes and trigger dashboard refresh\r\n      if (result.dataChanges && result.dataChanges.length > 0) {\r\n        console.log('üìä Data changes detected:', result.dataChanges);\r\n        \r\n        // Notify dashboard to refresh with a small delay to ensure backend save is complete\r\n        if (onDataChanged) {\r\n          setTimeout(() => {\r\n            console.log('üîÑ Triggering dashboard refresh...');\r\n            onDataChanged();\r\n          }, 100);\r\n        }\r\n      }\r\n      \r\n      // Handle confirmation requests\r\n      if (result.requiresConfirmation) {\r\n        setPendingConfirmation(result.confirmationData);\r\n        setIsWaitingForConfirmation(true);\r\n        \r\n        const confirmationMessage = {\r\n          role: 'assistant',\r\n          content: result.response || result.message,\r\n          timestamp: new Date().toISOString(),\r\n          id: Date.now() + 1,\r\n          requiresConfirmation: true,\r\n          sender: 'aetheris'\r\n        };\r\n        \r\n        setMessages(prev => [...prev, confirmationMessage]);\r\n      } else {\r\n        // Regular response - handle both response and message fields\r\n        const responseText = result.response || result.message || 'No response received';\r\n        \r\n        const assistantMessage = {\r\n          role: 'assistant',\r\n          content: responseText,\r\n          timestamp: result.timestamp || new Date().toISOString(),\r\n          id: Date.now() + 1,\r\n          sender: 'aetheris',\r\n          coresUsed: result.coresUsed || [],\r\n          newModule: result.newModule || null,\r\n          dataChanges: result.dataChanges || [] // Include data changes info for debugging\r\n        };\r\n        \r\n        setMessages(prev => [...prev, assistantMessage]);\r\n        \r\n        // Clear any pending confirmations\r\n        setPendingConfirmation(null);\r\n        setIsWaitingForConfirmation(false);\r\n      }\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Chat error:', error);\r\n      \r\n      const errorMessage = {\r\n        role: 'assistant',\r\n        content: `Sorry, I encountered an error: ${error.message}. Please check that your backend server is running on port 3000.`,\r\n        timestamp: new Date().toISOString(),\r\n        id: Date.now() + 1,\r\n        error: true,\r\n        sender: 'aetheris'\r\n      };\r\n      \r\n      setMessages(prev => [...prev, errorMessage]);\r\n      return { error: error.message };\r\n\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [onDataChanged]); // Add onDataChanged to dependencies\r\n\r\n  // Handle confirmation responses\r\n  const handleConfirmation = useCallback(async (confirmed) => {\r\n    if (!pendingConfirmation) return;\r\n\r\n    const confirmationText = confirmed ? 'yes' : 'no';\r\n    \r\n    // Add user's confirmation to chat\r\n    const confirmationMessage = {\r\n      role: 'user',\r\n      content: `Confirmation: ${confirmationText}`,\r\n      timestamp: new Date().toISOString(),\r\n      id: Date.now(),\r\n      isConfirmation: true,\r\n      sender: 'user'\r\n    };\r\n    \r\n    setMessages(prev => [...prev, confirmationMessage]);\r\n    \r\n    // Send confirmation to backend\r\n    const result = await sendMessage(confirmationText, true);\r\n    \r\n    // Clear confirmation state\r\n    setPendingConfirmation(null);\r\n    setIsWaitingForConfirmation(false);\r\n    \r\n    return result;\r\n  }, [pendingConfirmation, sendMessage]);\r\n\r\n  // Cancel pending confirmation\r\n  const cancelConfirmation = useCallback(() => {\r\n    setPendingConfirmation(null);\r\n    setIsWaitingForConfirmation(false);\r\n    \r\n    const cancelMessage = {\r\n      role: 'assistant',\r\n      content: 'Action cancelled.',\r\n      timestamp: new Date().toISOString(),\r\n      id: Date.now(),\r\n      sender: 'aetheris'\r\n    };\r\n    \r\n    setMessages(prev => [...prev, cancelMessage]);\r\n  }, []);\r\n\r\n  // Retry last message\r\n  const retryLastMessage = useCallback(() => {\r\n    const lastUserMessage = messages\r\n      .slice()\r\n      .reverse()\r\n      .find(msg => msg.sender === 'user');\r\n    \r\n    if (lastUserMessage) {\r\n      console.log('üîÑ Retrying last message:', lastUserMessage.content);\r\n      return sendMessage(lastUserMessage.content);\r\n    }\r\n  }, [messages, sendMessage]);\r\n\r\n  // Test connection\r\n  const testConnection = useCallback(async () => {\r\n    try {\r\n      const response = await fetch(`${API_BASE}/api/health`);\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        console.log('‚úÖ Backend connection test successful:', data);\r\n        return { success: true, data };\r\n      } else {\r\n        throw new Error(`HTTP ${response.status}`);\r\n      }\r\n    } catch (error) {\r\n      console.error('‚ùå Backend connection test failed:', error);\r\n      return { success: false, error: error.message };\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    messages,\r\n    isLoading,\r\n    pendingConfirmation,\r\n    isWaitingForConfirmation,\r\n    messagesEndRef,\r\n    showHistory,\r\n    allHistory,\r\n    sendMessage,\r\n    handleConfirmation,\r\n    cancelConfirmation,\r\n    loadChatHistory,\r\n    startFreshChat,\r\n    retryLastMessage,\r\n    testConnection,\r\n    clearChat: startFreshChat // Alias for backward compatibility\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}