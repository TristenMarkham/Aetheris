{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addOutputText = exports.validateInputTools = exports.shouldParseToolCall = exports.isAutoParsableTool = exports.makeParseableResponseTool = exports.hasAutoParseableInput = exports.parseResponse = exports.maybeParseResponse = void 0;\nconst error_1 = require(\"../error.js\");\nconst parser_1 = require(\"../lib/parser.js\");\nfunction maybeParseResponse(response, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...response,\n      output_parsed: null,\n      output: response.output.map(item => {\n        if (item.type === 'function_call') {\n          return {\n            ...item,\n            parsed_arguments: null\n          };\n        }\n        if (item.type === 'message') {\n          return {\n            ...item,\n            content: item.content.map(content => ({\n              ...content,\n              parsed: null\n            }))\n          };\n        } else {\n          return item;\n        }\n      })\n    };\n  }\n  return parseResponse(response, params);\n}\nexports.maybeParseResponse = maybeParseResponse;\nfunction parseResponse(response, params) {\n  const output = response.output.map(item => {\n    if (item.type === 'function_call') {\n      return {\n        ...item,\n        parsed_arguments: parseToolCall(params, item)\n      };\n    }\n    if (item.type === 'message') {\n      const content = item.content.map(content => {\n        if (content.type === 'output_text') {\n          return {\n            ...content,\n            parsed: parseTextFormat(params, content.text)\n          };\n        }\n        return content;\n      });\n      return {\n        ...item,\n        content\n      };\n    }\n    return item;\n  });\n  const parsed = Object.assign({}, response, {\n    output\n  });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n      return null;\n    }\n  });\n  return parsed;\n}\nexports.parseResponse = parseResponse;\nfunction parseTextFormat(params, content) {\n  if (params.text?.format?.type !== 'json_schema') {\n    return null;\n  }\n  if ('$parseRaw' in params.text?.format) {\n    const text_format = params.text?.format;\n    return text_format.$parseRaw(content);\n  }\n  return JSON.parse(content);\n}\nfunction hasAutoParseableInput(params) {\n  if ((0, parser_1.isAutoParsableResponseFormat)(params.text?.format)) {\n    return true;\n  }\n  return false;\n}\nexports.hasAutoParseableInput = hasAutoParseableInput;\nfunction makeParseableResponseTool(tool, {\n  parser,\n  callback\n}) {\n  const obj = {\n    ...tool\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexports.makeParseableResponseTool = makeParseableResponseTool;\nfunction isAutoParsableTool(tool) {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexports.isAutoParsableTool = isAutoParsableTool;\nfunction getInputToolByName(input_tools, name) {\n  return input_tools.find(tool => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return {\n    ...toolCall,\n    ...toolCall,\n    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null\n  };\n}\nfunction shouldParseToolCall(params, toolCall) {\n  if (!params) {\n    return false;\n  }\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\nexports.shouldParseToolCall = shouldParseToolCall;\nfunction validateInputTools(tools) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new error_1.OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n    }\n    if (tool.function.strict !== true) {\n      throw new error_1.OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n  }\n}\nexports.validateInputTools = validateInputTools;\nfunction addOutputText(rsp) {\n  const texts = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n  rsp.output_text = texts.join('');\n}\nexports.addOutputText = addOutputText;","map":{"version":3,"names":["error_1","require","parser_1","maybeParseResponse","response","params","hasAutoParseableInput","output_parsed","output","map","item","type","parsed_arguments","content","parsed","parseResponse","exports","parseToolCall","parseTextFormat","text","Object","assign","getOwnPropertyDescriptor","addOutputText","defineProperty","enumerable","get","format","text_format","$parseRaw","JSON","parse","isAutoParsableResponseFormat","makeParseableResponseTool","tool","parser","callback","obj","defineProperties","$brand","value","$callback","isAutoParsableTool","getInputToolByName","input_tools","name","find","toolCall","inputTool","tools","arguments","strict","shouldParseToolCall","validateInputTools","OpenAIError","function","rsp","texts","push","output_text","join"],"sources":["C:\\Users\\onetr\\OneDrive\\Desktop\\universal-business-platform\\node_modules\\openai\\src\\lib\\ResponsesParser.ts"],"sourcesContent":["import { OpenAIError } from '../error';\nimport type { ChatCompletionTool } from '../resources/chat/completions';\nimport {\n  ResponseTextConfig,\n  type FunctionTool,\n  type ParsedContent,\n  type ParsedResponse,\n  type ParsedResponseFunctionToolCall,\n  type ParsedResponseOutputItem,\n  type Response,\n  type ResponseCreateParamsBase,\n  type ResponseCreateParamsNonStreaming,\n  type ResponseFunctionToolCall,\n  type Tool,\n} from '../resources/responses/responses';\nimport { type AutoParseableTextFormat, isAutoParsableResponseFormat } from '../lib/parser';\n\nexport type ParseableToolsParams = Array<Tool> | ChatCompletionTool | null;\n\nexport type ResponseCreateParamsWithTools = ResponseCreateParamsBase & {\n  tools?: ParseableToolsParams;\n};\n\ntype TextConfigParams = { text?: ResponseTextConfig };\n\nexport type ExtractParsedContentFromParams<Params extends TextConfigParams> =\n  NonNullable<Params['text']>['format'] extends AutoParseableTextFormat<infer P> ? P : null;\n\nexport function maybeParseResponse<\n  Params extends ResponseCreateParamsBase | null,\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...response,\n      output_parsed: null,\n      output: response.output.map((item) => {\n        if (item.type === 'function_call') {\n          return {\n            ...item,\n            parsed_arguments: null,\n          };\n        }\n\n        if (item.type === 'message') {\n          return {\n            ...item,\n            content: item.content.map((content) => ({\n              ...content,\n              parsed: null,\n            })),\n          };\n        } else {\n          return item;\n        }\n      }),\n    };\n  }\n\n  return parseResponse(response, params);\n}\n\nexport function parseResponse<\n  Params extends ResponseCreateParamsBase,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\n  const output: Array<ParsedResponseOutputItem<ParsedT>> = response.output.map(\n    (item): ParsedResponseOutputItem<ParsedT> => {\n      if (item.type === 'function_call') {\n        return {\n          ...item,\n          parsed_arguments: parseToolCall(params, item),\n        };\n      }\n      if (item.type === 'message') {\n        const content: Array<ParsedContent<ParsedT>> = item.content.map((content) => {\n          if (content.type === 'output_text') {\n            return {\n              ...content,\n              parsed: parseTextFormat(params, content.text),\n            };\n          }\n\n          return content;\n        });\n\n        return {\n          ...item,\n          content,\n        };\n      }\n\n      return item;\n    },\n  );\n\n  const parsed: Omit<ParsedResponse<ParsedT>, 'output_parsed'> = Object.assign({}, response, { output });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n\n      return null;\n    },\n  });\n\n  return parsed as ParsedResponse<ParsedT>;\n}\n\nfunction parseTextFormat<\n  Params extends ResponseCreateParamsBase,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(params: Params, content: string): ParsedT | null {\n  if (params.text?.format?.type !== 'json_schema') {\n    return null;\n  }\n\n  if ('$parseRaw' in params.text?.format) {\n    const text_format = params.text?.format as unknown as AutoParseableTextFormat<ParsedT>;\n    return text_format.$parseRaw(content);\n  }\n\n  return JSON.parse(content);\n}\n\nexport function hasAutoParseableInput(params: ResponseCreateParamsWithTools): boolean {\n  if (isAutoParsableResponseFormat(params.text?.format)) {\n    return true;\n  }\n\n  return false;\n}\n\ntype ToolOptions = {\n  name: string;\n  arguments: any;\n  function?: ((args: any) => any) | undefined;\n};\n\nexport type AutoParseableResponseTool<\n  OptionsT extends ToolOptions,\n  HasFunction = OptionsT['function'] extends Function ? true : false,\n> = FunctionTool & {\n  __arguments: OptionsT['arguments']; // type-level only\n  __name: OptionsT['name']; // type-level only\n\n  $brand: 'auto-parseable-tool';\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\n  $parseRaw(args: string): OptionsT['arguments'];\n};\n\nexport function makeParseableResponseTool<OptionsT extends ToolOptions>(\n  tool: FunctionTool,\n  {\n    parser,\n    callback,\n  }: {\n    parser: (content: string) => OptionsT['arguments'];\n    callback: ((args: any) => any) | undefined;\n  },\n): AutoParseableResponseTool<OptionsT['arguments']> {\n  const obj = { ...tool };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n    $callback: {\n      value: callback,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableResponseTool<OptionsT['arguments']>;\n}\n\nexport function isAutoParsableTool(tool: any): tool is AutoParseableResponseTool<any> {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\n\nfunction getInputToolByName(input_tools: Array<Tool>, name: string): FunctionTool | undefined {\n  return input_tools.find((tool) => tool.type === 'function' && tool.name === name) as\n    | FunctionTool\n    | undefined;\n}\n\nfunction parseToolCall<Params extends ResponseCreateParamsBase>(\n  params: Params,\n  toolCall: ResponseFunctionToolCall,\n): ParsedResponseFunctionToolCall {\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n\n  return {\n    ...toolCall,\n    ...toolCall,\n    parsed_arguments:\n      isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\n      : inputTool?.strict ? JSON.parse(toolCall.arguments)\n      : null,\n  };\n}\n\nexport function shouldParseToolCall(\n  params: ResponseCreateParamsNonStreaming | null | undefined,\n  toolCall: ResponseFunctionToolCall,\n): boolean {\n  if (!params) {\n    return false;\n  }\n\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\n\nexport function validateInputTools(tools: ChatCompletionTool[] | undefined) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\n      );\n    }\n\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\n      );\n    }\n  }\n}\n\nexport function addOutputText(rsp: Response): void {\n  const texts: string[] = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n\n  rsp.output_text = texts.join('');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}